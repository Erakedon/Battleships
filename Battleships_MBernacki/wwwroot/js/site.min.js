class ShipsMap {

    //mapDOMRef;
    //mapTokens;
    //mapSize;

    //shipsLeft;


    constructor(containerId, _mapSize, shipsList) {
        this.mapDOMRef = new Array(_mapSize);
        this.containerId = containerId;

        console.log(this.containerId);
        this.generateMap(this.containerId);
        console.log(this.mapDOMRef);

        this.mapSize = _mapSize;
        this.shipsLeft = shipsList.slice();
        
        this.searchedCells = new Array(this.mapSize)

        this.mapTokens = new Array(_mapSize);
        for (var i = 0; i < _mapSize; i++) {
            this.mapTokens[i] = new Array(_mapSize);
            for (var j = 0; j < _mapSize; j++) {
                this.mapTokens[i][j] = 0;
            }
        }

    }


    generateMap(container) {
        //let arrayReference;
        //if (allegiance == "oponent") arrayReference = oponentCells;
        console.log(this.containerId);
        //else arrayReference = playerCells;

        for (let i = 0; i < this.mapSize; i++) {

            let row = document.createElement("div");
            row.classList.add('mapRow');

            this.mapDOMRef[i] = new Array(this.mapSize);

            for (let j = 0; j < this.mapSize; j++) {
                let cell = document.createElement("div");
                cell.classList.add('cell');
                //cell.onclick = () => { this.setShip(i,j) }

                this.mapDOMRef[i][j] = cell;

                row.appendChild(cell);
            }

            document.querySelector(this.containerId).appendChild(row)
        }
    }

    findBlank() {

        this.searchedCells = new Array(this.mapSize)
        for (var i = 0; i < this.mapSize; i++) {
            this.searchedCells[i] = new Array(this.mapSize);
            for (var j = 0; j < this.mapSize; j++) {
                this.searchedCells[i][j] = 0;
            }
        }

        let biggestShip = 0;
        this.shipsLeft.forEach((el, index) => {
            if (el > 0) biggestShip = index + 1;
        });
        console.log("biggestShip", biggestShip);
        

        let startOver = false;
        for (var i = 0; i < this.mapSize; i++) {
            for (var j = 0; j < this.mapSize; j++) {
                if (this.mapTokens[i][j] < 0 || this.searchedCells[i][j] == 1) continue;
                if (this.mapTokens[i][j] == 1) {

                    this.markSlants(i, j);

                    let sxNeg = this.findInDirection(i - 1, j, -1, 0);
                    let sxPos = this.findInDirection(i + 1, j, 1, 0);

                    let syNeg = this.findInDirection(i, j - 1, 0, -1);
                    let syPos = this.findInDirection(i, j + 1, 0, 1);

                    if (sxNeg + sxPos + syNeg + syPos > 0) {
                        console.log(sxNeg, sxPos, syNeg,syPos)
                    }

                    if (sxNeg + sxPos == biggestShip - 1) {
                        this.shipsLeft[biggestShip - 1] -= 1;
                        let x = i + sxPos;
                        if (x + 1 < this.mapSize) this.mapTokens[x + 1][j] = -1;
                        while (x >= i - sxNeg) {
                            this.mapTokens[x][j] = -2;
                            x--;
                        }
                        if (x + 1 > 0) this.mapTokens[x][j] = -1;
                        startOver = true;
                        break;
                    }
                    else if (syNeg + syPos == biggestShip - 1) {
                        this.shipsLeft[biggestShip - 1] -= 1;
                        let y = j + syPos;
                        if (y + 1 < this.mapSize) this.mapTokens[i][y + 1] = -1;
                        while (y >= j - syNeg) {
                            this.mapTokens[i][y] = -2;
                            y--;
                        }
                        if (y + 1 > 0) this.mapTokens[i][y] = -1;
                        startOver = true;
                        break;
                    }

                }

            }
            if (startOver) break;
        }
        if (startOver) this.findBlank();
    }

    markSlants(x, y) {
    //console.log(this);
    //console.log(this.this);
    if (x > 0) {
        if (y > 0) {
            this.searchedCells[x - 1][y - 1] = 1;
            this.mapTokens[x - 1][y - 1] = -1;
        }
        if (y + 1 < this.mapSize) {
            this.searchedCells[x - 1][y + 1] = 1;
            this.mapTokens[x - 1][y + 1] = -1;
        }
    }
    if (x + 1 < this.mapSize) {
        if (y > 0) {
            this.searchedCells[x + 1][y - 1] = 1;
            this.mapTokens[x + 1][y - 1] = -1;
        }
        if (y + 1 < this.mapSize) {
            this.searchedCells[x + 1][y + 1] = 1;
            this.mapTokens[x + 1][y + 1] = -1;
        }
    }
}

    findInDirection(x, y, dirX, dirY) {
    if (x < 0 || x + 1 > this.mapSize || y < 0 || y + 1 > this.mapSize) return 0;

        //if (this.mapTokens[x][y] < 0 || this.searchedCells[x][y] == 1) {
        //if (this.mapTokens[x][y] < 0) {
        //    this.searchedCells[x][y] = 1;
        //return 0;
        //}
    if (this.mapTokens[x][y] == 1) {
        this.searchedCells[x][y] = 1;
        this.markSlants(x, y);


        return 1 + this.findInDirection(x + dirX, y + dirY, dirX, dirY);
    }
        this.searchedCells[x][y] = 1;
        return 0;
}


    updateDOMMap() {
        //this.mapDOMRef.forEach((row,i) => {
        //    row.forEach((cell,j) => {

        //    });
        //})

        for (var i = 0; i < this.mapSize; i++) {
            for (var j = 0; j < this.mapSize; j++) {
                switch (this.mapTokens[i][j]) {
                    case -2:
                        this.mapDOMRef[i][j].classList.remove("ship");
                        this.mapDOMRef[i][j].classList.add("complete");
                        this.mapDOMRef[i][j].onclick = () => { return false };
                        break;
                    case -1:
                        this.mapDOMRef[i][j].onclick = () => { return false };
                        this.mapDOMRef[i][j].classList.add("miss");
                        break;
                    case 1:
                        this.mapDOMRef[i][j].onclick = () => { return false };
                        this.mapDOMRef[i][j].classList.add("ship");
                        break;
                }
            }
        }
    }

    //setShip(x, y) {
    //    console.log(x, y);
    //    this.mapTokens[x][y] = 1;

    //    this.findBlank();
    //    this.updateDOMMap();
    //}

}

class PlayerMap extends ShipsMap {


    constructor(containerId, _mapSize, shipsList, gameplayRef) {
        super(containerId, _mapSize, shipsList);
        this.gameplay = gameplayRef;
    }

    makeFieldsClickable() {
        console.log(this.mapDOMRef);
        for (let i = 0; i < this.mapSize; i++) {
            for (let j = 0; j < this.mapSize; j++) {
                this.mapDOMRef[i][j].onclick = () => { this.setShip(i, j) };
            }
        }
    }

    allShipsPlaced() {
        let result = true;
        this.shipsLeft.forEach(s => {
            console.log("ships left",s);
            if (s > 0) result = false;
        });
        return result;
    }

    setShip(x, y) {
        console.log(x, y);
        this.mapTokens[x][y] = 1;

        this.findBlank();
        this.updateDOMMap();
        if (this.allShipsPlaced()) {
            console.log("All ships placed!");
            this.setMapForGameplay();
            this.sendMap();
        }
    }



    setMapForGameplay() {
        for (let i = 0; i < this.mapSize; i++) {
            for (let j = 0; j < this.mapSize; j++) {

                this.mapDOMRef[i][j].onclick = () => { return 0 };
                this.mapDOMRef[i][j].classList.remove("ship", "miss", "complete");

                if (this.mapTokens[i][j] == -2) {
                    this.mapTokens[i][j] = 1;
                    this.mapDOMRef[i][j].classList.add("ship");
                }
                else if (this.mapTokens[i][j] == -1) {
                    this.mapTokens[i][j] = 0;
                }
            }
        }                          

    }


    sendMap() {

        let mapData = {
            map: this.mapTokens,
            roomID: this.gameplay.roomData.roomID,
            playerKey: this.gameplay.roomData.playerRoomKey
        }
        console.log("mapData", mapData)

        var options = {};
        options.url = "/api/room/PostMap";
        options.type = "POST";
        options.contentType = "application/json";
        options.data = JSON.stringify(mapData);
        options.dataType = "json";
        options.success = (data) => {
            console.log("Map Posted!", data);
            this.gameplay.watchForTurn();
            this.gameplay.oponentMap.setMapForGameplay();
        };
        options.error = (err) => {
            console.log(err);
        };
        $.ajax(options);

    }


}
class OponentMap extends ShipsMap {


    constructor(containerId, _mapSize, shipsList, gameplayRef) {
        super(containerId, _mapSize, shipsList);
        this.gameplay = gameplayRef;
        this.playerTurn = false;
    }

    enableMove() {
        this.playerTurn = true;
    }

    shoot(_x,_y) {
        if (!this.playerTurn) return;

        let shootInfo = {
            roomID: this.gameplay.roomData.roomID,
            playerKey: this.gameplay.roomData.playerRoomKey,
            x: _x,
            y: _y
        }
        console.log("shootInfo", shootInfo)

        var options = {};
        options.url = "/api/room/Shoot";
        options.type = "POST";
        options.contentType = "application/json";
        options.data = JSON.stringify(shootInfo);
        options.dataType = "json";
        options.success = (data) => {
            console.log("shooting result recieved", data);

            switch (data.lastAction.result) {
                case "win":
                    break;
                case "hit":
                    this.mapTokens[data.lastAction.x][data.lastAction.y] = 1;
                    this.mapDOMRef[data.lastAction.x][data.lastAction.y].classList.add("ship");
                    break;
                case "miss":
                    this.mapTokens[data.lastAction.x][data.lastAction.y] = -1;
                    this.mapDOMRef[data.lastAction.x][data.lastAction.y].classList.add("miss");
                    break

                default:
                    break;
            }
            this.findBlank();


            this.gameplay.watchForTurn();
        };
        options.error = (err) => {
            console.log(err);
        };
        $.ajax(options);

    }


    setMapForGameplay() {
        for (let i = 0; i < this.mapSize; i++) {
            for (let j = 0; j < this.mapSize; j++) {

                this.mapDOMRef[i][j].onclick = () => { this.shoot(i, j) };
              
            }
        }

    }

}
// Please see documentation at https://docs.microsoft.com/aspnet/core/client-side/bundling-and-minification
// for details on configuring this project to bundle and minify static web assets.

// Write your JavaScript code.




function submitNickname() {

    let input = document.querySelector("#nicknameInput");
    let errLabel = document.querySelector("#nicknameErrorLabel");

    errLabel.textContent = "";

    if (input.value.length < 3) {
        errLabel.textContent += "Nickname mus have at least 3 haracters";
        return;
    }

    let userNickname = input.value;

    localStorage.setItem('userNickname', JSON.stringify(userNickname));

    console.log("Nickname submitted: " + userNickname);

    //window.location.href = '@Url.Action("Lobby", "Home")' + '/';
    window.location.href = ('/home/lobby/');
}

function submitCreateRoom() {
    let nameInput = document.querySelector("#roomNameInput"); 
    let passwordInput = document.querySelector("#roomPasswordInput"); 
    let errLabel = document.querySelector("#roomNameErrorLabel");

    errLabel.textContent = "";

    if (nameInput.value.length < 1) {
        errLabel.textContent += "Room name cannot be blank";
    }
    else {
        let password = passwordInput.value || "";
        createNewRoom(nameInput.value, password);
        //window.location.href = ('/home/gameroom/' + data.roomID);
    }
    
}

function togglePopUp(popUpId) {
    let popUpEl = document.querySelector(popUpId);

    if (popUpEl.style.display == "none") popUpEl.style.display = "flex";
    else popUpEl.style.display = "none"
}

function checkIfNicknameSet() {
    let userNickname = JSON.parse(localStorage.getItem('userNickname'));


    //if (!userNickname) window.location.href = ('/home/index/');
}

function createNewRoom(roomname, roomPassword) {
    let userNickname = JSON.parse(localStorage.getItem('userNickname'));
    if (!userNickname) window.location.href = ('/home/index/');

    let roomCreationData =
    {
        roomName: roomname,
        playername: userNickname,
        password: roomPassword
    }
    
    var options = {};
    options.url = "/api/room/CreateRoom";
    options.type = "POST";
    options.contentType = "application/json";
    options.data = JSON.stringify(roomCreationData);
    options.dataType = "json";
    options.success = (data) => {
        console.log("Room succesfully created!", data);
        enterRoom(data);
    };
    options.error = () => {
        console.log("Server error");
    };
    $.ajax(options);    
}

function joinRoom(roomId, roomPassword) {
    console.log("joinRoom");
    let userNickname = JSON.parse(localStorage.getItem('userNickname'));
    if (!userNickname) window.location.href = ('/home/index/');

    let roomJoinData =
    {
        roomId: roomId,
        playername: userNickname,
        password: roomPassword
    }

    var options = {};
    options.url = "/api/room/JoinRoom";
    options.type = "POST";
    options.contentType = "application/json";
    options.data = JSON.stringify(roomJoinData);
    options.dataType = "json";
    options.success = (data) => {
        console.log("Room joined!", data);
        enterRoom(data);
    };
    options.error = (err) => {
        console.log(err);
    };
    $.ajax(options);
}

function enterRoom(roomData) {

    localStorage.setItem(roomData.roomID, JSON.stringify(roomData));

    window.location.href = ('/home/gameroom/' + roomData.roomID);
}

function updateRoomList(divToPassList) {


    let container = document.querySelector(divToPassList);
    console.log("divToPassList: ",divToPassList);
    while (container.firstChild) {
        container.removeChild(container.firstChild);
    }

        var options = {};
        options.url = "/api/room/GetRoomList";
        options.type = "GET";
        options.dataType = "json";
        options.success = function (data) {

            data.forEach(function (element) {
                console.log(element);




                //let roomDiv = "<div class='roomInfo'><div class='roomName'>"
                //    + element.roomName
                //    + "</div><div class='playerName'>"
                //    + element.ownerName + "</div>";
                ////roomDiv += element.requirePassword ? "<i class='fas fa-lock'></i></div>" : "<div></div></div>";
                //if (element.requirePassword) {
                //    roomDiv += "<i class='fas fa-lock'></i>";
                //    roomDiv.onclick = () => { togglePopUp(RoomPasswordPopUp) }
                //}
                //else {
                //    roomDiv.onclick = () => { joinRoom(element.roomID, ""); };
                //}
                //roomDiv += "</div>";




                let roomDiv = document.createElement("div");
                roomDiv.classList.add("roomInfo");

                let roomName = document.createElement("div");
                roomName.classList.add("roomName");
                roomName.textContent = element.roomName;

                let playerName = document.createElement("div");
                playerName.classList.add("playerName");
                playerName.textContent = element.ownerName;


                roomDiv.appendChild(roomName);
                roomDiv.appendChild(playerName);

                if (element.requirePassword) {
                    let icon = document.createElement("i");
                    icon.classList.add("fas", "fa-lock");
                    roomDiv.appendChild(icon);
                    roomDiv.onclick = () => { togglePopUp(RoomPasswordPopUp) }
                }
                else {
                    roomDiv.onclick = () => { joinRoom(element.roomID, ""); };
                }

                document.querySelector(divToPassList).appendChild(roomDiv);
            });
        };
        options.error = function () {
            $("#msg").html("Error while calling the Web API!");
        };
        $.ajax(options);
}
let Gameplay = {

    //mapSize = 6,
    //shipsList = [0, 2, 1, 1], //Index + 1 is the indicator of ship size

    //roomData,

    //playerMap,
    //oponentMap,

    initializeGameplay(roomId) {

        this.gameStateDiv = document.querySelector("#gamestate");
        this.gameRoomNameDiv = document.querySelector("#roomName");
        this.oponentNameDiv = document.querySelector("#oponentName");


        this.roomData = JSON.parse(localStorage.getItem(roomId));
        console.log(this.roomData);

        this.gameRoomNameDiv.innerText = this.roomData.roomName;

        this.mapSize = 6,
        this.shipsList = [0, 2, 1, 1], //Index + 1 is the indicator of ship size

        this.playerMap = new PlayerMap("#playerMap", this.mapSize, this.shipsList,this);
        this.playerMap.generateMap();
        this.gameStateDiv.innerText = "Place your Ships";
        this.playerMap.makeFieldsClickable();

        this.oponentMap = new OponentMap("#oponentMap", this.mapSize, this.shipsList,this);
        this.oponentMap.generateMap();

    },

    watchForTurn() {

        let query = {
            roomID: this.roomData.roomID,
            playerKey: this.roomData.playerRoomKey
        }
        console.log("query", query)

        var options = {};
        options.url = "/api/room/Gamestate";
        options.type = "POST";
        options.contentType = "application/json";
        options.data = JSON.stringify(query);
        options.dataType = "json";
        options.success = (data) => {
            console.log("room state recieved", data);

            if (data.oponentName == "") this.oponentNameDiv.innerText = "Waiting for oponent";
            else this.oponentNameDiv.innerText = "Oponent: " + data.oponentName;

            if (data.gameOn) {
                if (data.askingPlayerTurn) {
                    this.gameStateDiv.innerText = "Your Turn!";
                    this.oponentMap.enableMove();
                } else {
                    this.gameStateDiv.innerText = "Waiting for oponent";
                    setTimeout(() => { this.watchForTurn() }, 2000);
                }

            } else {
                this.gameStateDiv.innerText = "Waiting for oponent";
                setTimeout(() => { this.watchForTurn() }, 2000);
            }


        };
        options.error = (err) => {
            console.log(err);
        };
        $.ajax(options);


    }


}



//let mapSize = 6;
//let shipsList = [0, 2, 1, 1];//Index + 1 is the indicator of ship size

//let oponentCells = new Array(mapSize);
//let playerCells = new Array(mapSize);

//let playerMap;

//function initializeGameplay() {
//    playerMap = new PlayerMap("#playerMap", mapSize, shipsList);

//}


//function generateMap(parent, allegiance) {
//    let arrayReference;
//    if (allegiance == "oponent") arrayReference = oponentCells;
//    else arrayReference = playerCells;
    
//    for (var i = 0; i < mapSize; i++) {

//        let row = document.createElement("div");
//        row.classList.add('mapRow');

//        arrayReference[i] = new Array(mapSize);

//        for (var j = 0; j < mapSize; j++) {
//            let cell = document.createElement("div");
//            cell.classList.add('cell');

//            arrayReference[i][j] = cell;

//            row.appendChild(cell);
//        }

//        document.querySelector(parent).appendChild(row)
//    }

//    console.log(oponentCells);
//    console.log(playerCells);

//}