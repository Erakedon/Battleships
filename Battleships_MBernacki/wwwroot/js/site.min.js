class ShipsMap {

    constructor(containerId, _mapSize, shipsList) {
        this.mapDOMRef = new Array(_mapSize);
        this.containerId = containerId;

        this.generateMap(this.containerId);

        this.mapSize = _mapSize;
        this.shipsLeft = shipsList.slice();
        
        this.searchedCells = new Array(this.mapSize)

        this.mapTokens = new Array(_mapSize);
        for (var i = 0; i < _mapSize; i++) {
            this.mapTokens[i] = new Array(_mapSize);
            for (var j = 0; j < _mapSize; j++) {
                this.mapTokens[i][j] = 0;
            }
        }
    }

    generateMap(container) {
        console.log(this.containerId);

        for (let i = 0; i < this.mapSize; i++) {

            let row = document.createElement("div");
            row.classList.add('mapRow');

            this.mapDOMRef[i] = new Array(this.mapSize);

            for (let j = 0; j < this.mapSize; j++) {
                let cell = document.createElement("div");
                cell.classList.add('cell');

                this.mapDOMRef[i][j] = cell;

                row.appendChild(cell);
            }
            document.querySelector(this.containerId).appendChild(row)
        }
    }

    findBlank() {

        this.searchedCells = new Array(this.mapSize)
        for (var i = 0; i < this.mapSize; i++) {
            this.searchedCells[i] = new Array(this.mapSize);
            for (var j = 0; j < this.mapSize; j++) {
                this.searchedCells[i][j] = 0;
            }
        }

        let biggestShip = 0;
        this.shipsLeft.forEach((el, index) => {
            if (el > 0) biggestShip = index + 1;
        });
        console.log("biggestShip", biggestShip);
        

        let startOver = false;
        for (var i = 0; i < this.mapSize; i++) {
            for (var j = 0; j < this.mapSize; j++) {
                if (this.mapTokens[i][j] < 0 || this.searchedCells[i][j] == 1) continue;
                if (this.mapTokens[i][j] == 1) {

                    this.markSlants(i, j);

                    let sxNeg = this.findInDirection(i - 1, j, -1, 0);
                    let sxPos = this.findInDirection(i + 1, j, 1, 0);

                    let syNeg = this.findInDirection(i, j - 1, 0, -1);
                    let syPos = this.findInDirection(i, j + 1, 0, 1);

                    if (sxNeg + sxPos + syNeg + syPos > 0) {
                        console.log(sxNeg, sxPos, syNeg,syPos)
                    }

                    if (sxNeg + sxPos == biggestShip - 1) {
                        this.shipsLeft[biggestShip - 1] -= 1;
                        let x = i + sxPos;
                        if (x + 1 < this.mapSize) this.mapTokens[x + 1][j] = -1;
                        while (x >= i - sxNeg) {
                            this.mapTokens[x][j] = -2;
                            x--;
                        }
                        if (x + 1 > 0) this.mapTokens[x][j] = -1;
                        startOver = true;
                    }
                    if (syNeg + syPos == biggestShip - 1) {
                        if (!startOver) this.shipsLeft[biggestShip - 1] -= 1;
                        let y = j + syPos;
                        if (y + 1 < this.mapSize) this.mapTokens[i][y + 1] = -1;
                        while (y >= j - syNeg) {
                            this.mapTokens[i][y] = -2;
                            y--;
                        }
                        if (y + 1 > 0) this.mapTokens[i][y] = -1;
                        startOver = true;
                    }
                    if (startOver) break;
                }
            }
            if (startOver) break;
        }
        if (startOver) this.findBlank();
    }

    markSlants(x, y) {
    if (x > 0) {
        if (y > 0) {
            this.searchedCells[x - 1][y - 1] = 1;
            this.mapTokens[x - 1][y - 1] = -1;
        }
        if (y + 1 < this.mapSize) {
            this.searchedCells[x - 1][y + 1] = 1;
            this.mapTokens[x - 1][y + 1] = -1;
        }
    }
    if (x + 1 < this.mapSize) {
        if (y > 0) {
            this.searchedCells[x + 1][y - 1] = 1;
            this.mapTokens[x + 1][y - 1] = -1;
        }
        if (y + 1 < this.mapSize) {
            this.searchedCells[x + 1][y + 1] = 1;
            this.mapTokens[x + 1][y + 1] = -1;
        }
    }
}

    findInDirection(x, y, dirX, dirY) {
    if (x < 0 || x + 1 > this.mapSize || y < 0 || y + 1 > this.mapSize) return 0;

    if (this.mapTokens[x][y] == 1) {
        this.searchedCells[x][y] = 1;
        this.markSlants(x, y);


        return 1 + this.findInDirection(x + dirX, y + dirY, dirX, dirY);
    }
        this.searchedCells[x][y] = 1;
        return 0;
}


    updateDOMMap() {

        for (var i = 0; i < this.mapSize; i++) {
            for (var j = 0; j < this.mapSize; j++) {
                this.mapDOMRef[i][j].classList.remove("ship", "miss", "complete");
                switch (this.mapTokens[i][j]) {
                    case -2:
                        this.mapDOMRef[i][j].classList.add("complete");
                        break;
                    case -1:
                        this.mapDOMRef[i][j].onclick = () => { return false };
                        this.mapDOMRef[i][j].classList.add("miss");
                        break;
                    case 1:
                        this.mapDOMRef[i][j].classList.add("ship");
                        break;
                }
            }
        }
    }

}

class PlayerMap extends ShipsMap {

    constructor(containerId, _mapSize, shipsList, gameplayRef) {
        super(containerId, _mapSize, shipsList);
        this.shipsList = shipsList;
        this.gameplay = gameplayRef;
    }

    makeFieldsClickable() {
        console.log(this.mapDOMRef);
        for (let i = 0; i < this.mapSize; i++) {
            for (let j = 0; j < this.mapSize; j++) {
                this.mapDOMRef[i][j].onclick = () => { this.setShip(i, j) };
            }
        }
    }

    allShipsPlaced() {
        let result = true;
        this.shipsLeft.forEach(s => {
            console.log("ships left",s);
            if (s != 0) result = false;
        });
        return result;
    }

    setShip(x, y) {
        console.log(x, y);
        this.mapTokens[x][y] = 1;

        this.findBlank();
        this.updateDOMMap();
        this.gameplay.updateShipsListDiv(this.shipsLeft);
        this.mapDOMRef[x][y].onclick = () => { this.removeShip(x, y) };
        if (this.allShipsPlaced()) {
            console.log("All ships placed!");
            document.querySelector(this.containerId).classList.remove("clickable");
            document.querySelector(this.gameplay.oponentMap.containerId).classList.add("clickable");
            this.setMapForGameplay();
            this.gameplay.hideShipsListDiv();
            this.gameplay.oponentMap.showMap();
            this.sendMap();
        }
    }

    removeShip(x, y) {
        console.log("rmvShp",x, y);
        this.mapTokens[x][y] = 0;

        this.removeMiss();
        this.renewCompleted();
        this.shipsLeft = this.shipsList.slice();


        this.findBlank();
        this.updateDOMMap();
        this.gameplay.updateShipsListDiv(this.shipsLeft);
        this.mapDOMRef[x][y].onclick = () => { this.setShip(x, y) };
        this.makeBlankClickable();
    }

    removeMiss() {
        for (var i = 0; i < this.mapSize; i++) {
            for (var j = 0; j < this.mapSize; j++) {
                if (this.mapTokens[i][j] == -1) {
                    this.mapTokens[i][j] = 0;
                }
            }
        }
    }

    makeBlankClickable() {
        for (let i = 0; i < this.mapSize; i++) {
            for (let j = 0; j < this.mapSize; j++) {
                if (this.mapTokens[i][j] == 0) {
                    this.mapDOMRef[i][j].onclick = () => { this.setShip(i, j) };
                }
            }
        }
    }

    renewCompleted() {
        for (var i = 0; i < this.mapSize; i++) {
            for (var j = 0; j < this.mapSize; j++) {
                if (this.mapTokens[i][j] == -2) this.mapTokens[i][j] = 1;
            }
        }
    }

    setMapForGameplay() {
        for (let i = 0; i < this.mapSize; i++) {
            for (let j = 0; j < this.mapSize; j++) {

                this.mapDOMRef[i][j].onclick = () => { return 0 };
                this.mapDOMRef[i][j].classList.remove("ship", "miss", "complete");

                if (this.mapTokens[i][j] == -2) {
                    this.mapTokens[i][j] = 1;
                    this.mapDOMRef[i][j].classList.add("ship");
                }
                else if (this.mapTokens[i][j] == -1) {
                    this.mapTokens[i][j] = 0;
                }
            }
        }                       
    }

    sendMap() {

        let mapData = {
            map: this.mapTokens,
            roomID: this.gameplay.roomData.roomID,
            playerKey: this.gameplay.roomData.playerRoomKey
        }
        console.log("mapData", mapData)

        var options = {};
        options.url = "/api/room/PostMap";
        options.type = "POST";
        options.contentType = "application/json";
        options.data = JSON.stringify(mapData);
        options.dataType = "json";
        options.success = (data) => {
            console.log("Map Posted!", data);
            this.gameplay.watchForTurn();
            this.gameplay.oponentMap.setMapForGameplay();
        };
        options.error = (err) => {
            console.log(err);
            window.location.href = ('/home/lobby/' + roomData.roomID);
        };
        $.ajax(options);
    }
}
class OponentMap extends ShipsMap {

    constructor(containerId, _mapSize, shipsList, gameplayRef) {
        super(containerId, _mapSize, shipsList);
        this.gameplay = gameplayRef;
        this.playerTurn = false;
    }

    enableMove() {
        this.playerTurn = true;
    }

    shoot(_x,_y) {
        if (!this.playerTurn) return;

        let shootInfo = {
            roomID: this.gameplay.roomData.roomID,
            playerKey: this.gameplay.roomData.playerRoomKey,
            x: _x,
            y: _y
        }
        console.log("shootInfo", shootInfo)

        var options = {};
        options.url = "/api/room/Shoot";
        options.type = "POST";
        options.contentType = "application/json";
        options.data = JSON.stringify(shootInfo);
        options.dataType = "json";
        options.success = (data) => {
            console.log("shooting result recieved", data);

            switch (data.lastAction.result) {
                case "win":
                    this.mapTokens[data.lastAction.x][data.lastAction.y] = 1;
                    break;
                case "hit":
                    this.mapTokens[data.lastAction.x][data.lastAction.y] = 1;
                    break;
                case "miss":
                    this.mapTokens[data.lastAction.x][data.lastAction.y] = -1;
                    break

                default:
                    break;
            }
            this.findBlank();
            this.updateDOMMap();

            this.gameplay.watchForTurn();
        };
        options.error = (err) => {
            console.log(err);
        };
        $.ajax(options);

    }


    setMapForGameplay() {
        for (let i = 0; i < this.mapSize; i++) {
            for (let j = 0; j < this.mapSize; j++) {
                this.mapDOMRef[i][j].onclick = () => { this.shoot(i, j) };              
            }
        }
    }

    hideMap() {
        document.querySelector(this.containerId).style.display = "none";
    }

    showMap() {
        document.querySelector(this.containerId).style.display = "block";
    }

}
// Please see documentation at https://docs.microsoft.com/aspnet/core/client-side/bundling-and-minification
// for details on configuring this project to bundle and minify static web assets.

// Write your JavaScript code.



function submitCreateRoom() {
    let nameInput = document.querySelector("#roomNameInput"); 
    let errLabel = document.querySelector("#roomNameErrorLabel");

    errLabel.textContent = "";

    if (nameInput.value.length < 1) {
        errLabel.textContent += "Room name cannot be blank";
    }
    else {
        createNewRoom(nameInput.value);
    }    
}

function togglePopUp(popUpId) {
    let popUpEl = document.querySelector(popUpId);

    if (popUpEl.style.display == "none") popUpEl.style.display = "flex";
    else popUpEl.style.display = "none"
}

function toggleOptions(elementId,optionsBtnId) {
    let el = document.querySelector(elementId);
    let optionsBtn = document.querySelector(optionsBtnId);

    if (el.style.display == "flex") {
        el.style.display = "none";
        optionsBtn.innerText = "Show options";
    }
    else {
        el.style.display = "flex";
        optionsBtn.innerText = "Hide options";
    }

}

function createNewRoom(roomname) {

    let mapSize = document.querySelector("#mapSizeInput").value || 6;

    let shipsMapInputs = document.querySelector("#shipListInputContainer").querySelectorAll("input");

    console.log(shipsMapInputs);
    let shipsList = [];
    if (shipsMapInputs.length == 4) {
        for (var i = 0; i < 4; i++) {
            shipsList[i] = shipsMapInputs[i].value;
            console.log(shipsMapInputs[i].value);
        }
    } else
        shipsList = [0, 2, 1, 1];
    

    let roomCreationData =
    {
        roomName: roomname,
        mapSize: mapSize,
        shipsList: shipsList

    }
    
    var options = {};
    options.url = "/api/room/CreateRoom";
    options.type = "POST";
    options.contentType = "application/json";
    options.data = JSON.stringify(roomCreationData);
    options.dataType = "json";
    options.success = (data) => {
        console.log("Room succesfully created!", data);
        enterRoom(data);
    };
    options.error = () => {
        console.log("Server error");
    };
    $.ajax(options);    
}

function joinRoom(roomId) {

    let roomJoinData =
    {
        roomId: roomId
    }

    var options = {};
    options.url = "/api/room/JoinRoom";
    options.type = "POST";
    options.contentType = "application/json";
    options.data = JSON.stringify(roomJoinData);
    options.dataType = "json";
    options.success = (data) => {
        console.log("Room joined!", data);
        enterRoom(data);
    };
    options.error = (err) => {
        console.log(err);
        window.location.href = ('/home/lobby/' + roomData.roomID);
    };
    $.ajax(options);
}

function enterRoom(roomData) {

    localStorage.setItem(roomData.roomID, JSON.stringify(roomData));

    window.location.href = ('/home/gameroom/' + roomData.roomID);
}

function updateRoomList(divToPassList) {


    let container = document.querySelector(divToPassList);
    console.log("divToPassList: ",divToPassList);
    while (container.firstChild) {
        container.removeChild(container.firstChild);
    }

        var options = {};
        options.url = "/api/room/GetRoomList";
        options.type = "GET";
        options.dataType = "json";
        options.success = function (data) {

            data.forEach(function (element) {
                console.log(element);

                let roomDiv = document.createElement("div");
                roomDiv.classList.add("roomInfo");

                let roomName = document.createElement("div");
                roomName.classList.add("roomName");
                roomName.textContent = element.roomName;

                let playerName = document.createElement("div");
                playerName.classList.add("playerName");
                playerName.textContent = element.ownerName;


                roomDiv.appendChild(roomName);
                roomDiv.appendChild(playerName);

                if (element.requirePassword) {
                    let icon = document.createElement("i");
                    icon.classList.add("fas", "fa-lock");
                    roomDiv.appendChild(icon);
                    roomDiv.onclick = () => { togglePopUp(RoomPasswordPopUp) }
                }
                else {
                    roomDiv.onclick = () => { joinRoom(element.roomID); };
                }

                document.querySelector(divToPassList).appendChild(roomDiv);
            });
        };
        options.error = function () {
            $("#msg").html("Error while calling the Web API!");
        };
        $.ajax(options);
}
let Gameplay = {

    initializeGameplay(roomId) {

        this.gameStateDiv = document.querySelector("#gamestate");
        this.gameRoomNameDiv = document.querySelector("#roomName");
        this.oponentNameDiv = document.querySelector("#oponentName");


        this.roomData = JSON.parse(localStorage.getItem(roomId));
        console.log(this.roomData);
        if (!this.roomData) {
            joinRoom(roomId);
            //this.initializeGameplay(roomId);
            return;
        }

        this.gameRoomNameDiv.innerText = this.roomData.roomName;

        this.mapSize = this.roomData.mapSize,
        this.shipsList = this.roomData.shipsList, //Index + 1 is the indicator of ship size

        this.playerMap = new PlayerMap("#playerMap", this.mapSize, this.shipsList,this);
        this.playerMap.generateMap();
        this.gameStateDiv.innerText = "Place your Ships";
        this.playerMap.makeFieldsClickable();

        this.oponentMap = new OponentMap("#oponentMap", this.mapSize, this.shipsList,this);
        this.oponentMap.generateMap();
        this.oponentMap.hideMap();

        this.shipsListDiv = document.querySelector("#shipsList");
        this.updateShipsListDiv(this.roomData.shipsList);

    },

    watchForTurn() {

        let query = {
            roomID: this.roomData.roomID,
            playerKey: this.roomData.playerRoomKey
        }
        console.log("query", query)

        var options = {};
        options.url = "/api/room/Gamestate";
        options.type = "POST";
        options.contentType = "application/json";
        options.data = JSON.stringify(query);
        options.dataType = "json";
        options.success = (data) => {
            console.log("room state recieved", data);

            if (data.oponentName == "") this.oponentNameDiv.innerText = "Waiting for oponent";
            else this.oponentNameDiv.innerText = "Oponent: " + data.oponentName;

            console.log(data);
            if (data.lastAction && data.lastAction.result == "win") {
                this.gameStateDiv.innerText = data.lastAction.playerName + " have won!";
                document.querySelector("#backToLobby").style.display = "block";
            }
            else if (data.gameOn) {
                if (data.askingPlayerTurn) {

                    if (data.lastAction) {


                        switch (data.lastAction.result) {
                            case "hit":
                                this.playerMap.mapTokens[data.lastAction.x][data.lastAction.y] = -2;
                                break;
                            case "miss":
                                this.playerMap.mapTokens[data.lastAction.x][data.lastAction.y] = -1;
                                break;
                            default:
                        }
                        this.playerMap.updateDOMMap();
                    }


                    this.gameStateDiv.innerText = "Your Turn!";
                    this.oponentMap.enableMove();
                }
                else {
                    this.gameStateDiv.innerText = "Waiting for oponent";
                    setTimeout(() => { this.watchForTurn() }, 2000);
                }

            }
            else {
                this.gameStateDiv.innerText = "Waiting for oponent";
                setTimeout(() => { this.watchForTurn() }, 2000);
            }

        };
        options.error = (err) => {
            console.log(err);
        };
        $.ajax(options);
    },

    updateShipsListDiv(actualShipsLeft) {
        let shipTypeDiv = this.shipsListDiv.querySelectorAll(".shipType");
        actualShipsLeft.forEach((s, i) => {
            if (s == 0) shipTypeDiv[i].style.display = "none";
            else shipTypeDiv[i].style.display = "flex";
            shipTypeDiv[i].querySelector("p").innerText = s;
        });
    },

    hideShipsListDiv() {
        this.shipsListDiv.style.display = "none";
    }

}